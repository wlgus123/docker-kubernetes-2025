# DOCKER&**Kubernetes**

- 작동 배경 살펴보기 : 이미지 검사

<이미지 생성을 하기 위한 Dockerfile>

! 이미지가 빌드된 이후 이미지 안은 잠기게 되고 수정할 수 없게 됨.

```docker
FROM node

WORKDIR /app

COPY . /app

RUN npm install

EXPOSE 80

CMD ["node", "server.js"]
```

터미널에서 이미지 쪽으로 접근하는 명령어 ( 로컬 시스템에 저장된 docker 이미지 목록을 확인하는 명령어)

> $ docker images

* COPY . . 를 진행할 때 기본적으로 소스 코드를 “이미지에 복사”하고 복사한 시점에서 소스코드의 스냅샷(캡처)을 만듦.

## 이미지 검사가 필요한 경우

컨테이너 이미지 내부의 보안 취약점을 찾아내는 과정

실행 중인 컨테이너는 실제로 크지가 않음.

명령 레이어가 이미지 위에 추가된 얇은 부가 레이어인데 따라서 해당된 이미지 코드는 실행 중인 컨테이너에서 사용이 됨. 복사도 안 됨.

컨테이너는 이미지를 기반으로 빌드가 됨.

동일한 이미지를 기반으로 실행되는 여러 컨테이너는 이미지 내부의 코드를 공유함.

그렇기에 이미지 내부의 이 코드는 잠겨져있음

만약 변경을 한다고 하더라도 읽기 전용 컨테이너만 변경할 수 있다.

Q. 만약 이미지 정보에 대해 더 알고 싶다면?

> docker image inspect 이미지ID

그럼 이미지의 풀 iD 가 출력이 되는 것은 물론이며 생성된 날짜와 시도 나오게 됨.

노출될 포트, 자동으로 설정되는 일부 환경 변수, 커스텀 진입점을 지정하지 않는 경우 ETRYPOINT까지, dockerversion  등등 자세한 정보가 많음

ETRYPOINT: 컨테이너가 시작될 때 자동으로 실행되는 프로그램 또는 스크립트를 설정하는 것

## **1️⃣ Docker 이미지 실행 과정**

Docker 이미지는 여러 개의 레이어로 구성되어 있어있음.

컨테이너를 실행할 때 Docker는 **이미 존재하는 레이어를 재사용**해서 실행 속도를 빠르게 만드는데 이때 실행 과정.

✅ **Docker 이미지 실행 과정:**

1. `docker run 이미지이름` 명령어 입력
2. Docker가 해당 **이미지를 다운로드**하거나 **로컬에서 찾음**
3. 이미지에서 컨테이너를 생성 (읽기 전용 레이어)
4. 컨테이너 실행 (읽기-쓰기 가능한 레이어 추가)
5. 실행된 컨테이너가 종료되면, 변경 사항은 컨테이너 내부에만 저장됨 (이미지 자체는 변하지 않음)

## **2️⃣ Docker 재실행 시 전체 빌드를 하지 않는 이유**

Docker는 **캐시(cache)와 레이어(layer) 시스템**을 이용해서 불필요한 빌드를 피하고, 이미 만들어진 부분을 재사용해!

✅ **빌드할 때 캐시 활용하는 방법:**

- `docker build`를 실행하면 Docker는 **변경되지 않은 레이어를 그대로 유지**하고,변경된 부분만 다시 빌드해.
- 그래서 **모든 과정을 다시 실행하지 않고, 필요한 부분만 업데이트**하는 거야.

결론: 이래서 베이스 이미지에 레이어가 있는 이

*강의 보는 것만으로는 잘 이해가 안 되어 chatgpt 힘을 빌렸습니다.

<aside>
💡

이때 우리가 알 수 있는 점은 매번 docker에 패키지를 매번 설치하지 않고, 이미지 내부에 설치를 한 번만 한다면 더이상 할 필요가 없다는 것이다.

</aside>

---

## 이미지 공유하는 방법

1. Dockerfile과 이 애플리케이션에 속한 소스 코드를 제

→ 자체 이미지 빌드하여 컨테이너 실행할 수 있음.

추가 경로나 주변 폴도가 필요함.

1. 터미널에 $ docker run node라고 명령어 입력

→ 최근 노드 이미지 다운로드하여 이를 바탕으로 실행

(즉 완성된 이미지를 공유하는 것.)

이미지 한 번만으로 실행이 가능함.
